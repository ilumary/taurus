\chapter{Introduction}

Over the past four decades, the reliability of the Transmission Control Protocol (TCP) has been the cornerstone of typical, day-to-day user traffic on the Internet. TCP, renowned for its ability to provide reliable, ordered, and error-checked data transmission between two applications, has been the foundation in sustaining the connectivity that underpins our digital experiences. However, the ever-accelerating evolution of network landscapes, coupled with an intensifying demand for heightened flexibility, security, and superior performance, has catalyzed in the exploration of alternatives. In response to these demands, the QUIC protocol has emerged as a solution to next-generation networking, with its roots tracing back to the laboratories of Google itself. In a contemporary environment where the static nature of traffic from predominantly home networks has given way to a dynamic mix of devices, networks and technologies, QUIC represents the much needed next step in networking. Unlike its predecessor, QUIC is designed to meet the challenges of a modernized digital ecosystem, where seamless and secure connections are imperative across a diverse array of devices and scenarios. As our lives become increasingly interconnected and reliant on a myriad of digital interfaces, QUIC stands as the much-needed next step, ensuring not only reliability but also security.

\section{Motivation}

The motivation behind this bachelor's thesis stems from the imperative to explore and comprehend the intricacies of the QUIC protocol. By undertaking the development of a deliberately small version of QUIC in the Rust programming language, this thesis seeks to dissect the protocol's core components, facilitating a nuanced understanding of its inner workings. 

The primary focus lies on the deliberate simplicity of the Rust implementation, allowing us to delve into specific aspects of QUIC without the burden of unnecessary complexities. This approach enables a detailed examination of QUIC's distinctive features, such as its transport, encryption, multiplexing, and error-handling mechanisms, shedding light on the protocol's robustness, performance and adaptability.

Moreover, the implementation in Rust serves a dual purpose. Rust, celebrated for its emphasis on memory safety, performance, and concurrency, provides a unique lens through which to analyze the intricacies of QUIC. The choice of Rust as the implementation language is motivated by its suitability for systems programming, aligning with the low-level requirements of a protocol like QUIC. 

The overarching goal of this thesis is not merely the creation of a Rust implementation of QUIC but a comprehensive analysis of QUIC's advancements over TCP. By drawing comparisons between the two protocols, we aim to discern the specific attributes that render QUIC superior in certain contexts. This investigation is crucial for understanding the potential transformative impact of QUIC on the future of networking, particularly in the face of emerging technologies, diversified device ecosystems and the ever-growing demand for low-latency, secure communication.

In essence, the motivating force behind this bachelor's thesis originates from a personal fascination with both the QUIC protocol and the Rust programming language. The convergence of these two technologies presents an intriguing synergy, prompting an exploration into their compatibility and the potential insights gained from their combination. Through comparative assessments between QUIC and TCP, we seek to identify the specific attributes that position QUIC as superior in certain contexts. This investigation becomes pivotal in understanding the transformative potential of QUIC in the field of networking.

\section{Objective}

This bachelor's thesis objective is to implement a standalone version of the QUIC transport protocol in Rust, utilizing version rustc 1.72.0 and the UDP-Socket from the Rust standard library as its foundation. The implementation aims to encompass several features crucial for a functional QUIC server endpoint. These include the ability to send and receive QUIC packets, parsing, and encryption/decryption of both header and payload data. Additionally, the system aims to support a fully executed 1-RTT QUIC handshake between two endpoints, employing TLS 1.3 through the Rustls crate.

In developing this implementation, reference is primarily made to RFCs 8999-9001, chosen due to a lack of comparable open-source implementations in Rust. The project focuses on handling all frames within the payload, with special attention given to Cryptoframes and Dataframes.

The implementation incorporates essential tools, such as the Rustls crate with the "quic" feature for a complete TLS 1.3 implementation and the Octets crate, serving as a Rust zero-copy mutable Byte Buffer to facilitate parsing.

Certain features are deliberately omitted due to time constraints. These include 0-RTT packets, version negotiation between different QUIC versions, connection migration, and advanced flow control.

Optional features that may be considered based on the ongoing progress of the project include multithreading in the server endpoint, QUIC flow control, and the potential inclusion of a client endpoint.

The primary communication goal is to establish seamless communication with a Python-implemented client. This client initiates the handshake and subsequently sends individual data packets as payloads, awaiting acknowledgment from the Rust-based server. Notably, the Python QUIC client is implemented using the open-source implementation aioquic.

Furthermore this bachelor's thesis aims to undertake a comprehensive exploration of the QUIC protocol, delving into its intricacies and functionalities. By examining QUIC's features, particularly its transport, encryption, multiplexing, and error-handling mechanisms, one can better discern how QUIC stands out in terms of resilience, efficiency, and security when compared to TCP.

\section{Overview}

Starting with the subsequent chapter, "Fundamentals", the thesis establishes a foundation for understanding the principles of QUIC. Key terms and definitions are clarified, followed by an introduction into networking protocol fundamentals. Furthermore, both TCP and UDP are introduced in more detail.

Chapter three forms the core of the thesis, in which QUIC is examined in detail. It starts by exploring QUIC's historical background, clarifying its goals in addressing problems faced by TCP and other protocols, and continues with a detailed breakdown of its architecture. Moving into the more practical part of QUIC, the following subsections break down its connections and the ways in which QUIC deals with different errors and how it recovers. Finally, we examine the security features integrated into QUIC.

Moving into the implementation chapter, we learn about the rationale behind choosing Rust as the implementation language and the scope of the QUIC implementation, followed by the development environment specifics and all external libraries the implementation makes use of. The main part of chapter four deals with the library layout and dives deep into specifics of connection establishment, packet handling and stream management. Lastly we will examine both protocol and implementation error handling mechanisms before concluding the chapter with an overview of the strategies used to test and validate parts of the implementation.

The "Evaluation" chapter critically assesses the implemented QUIC protocol. It addresses encountered challenges, acknowledges inherent limitations, evaluates performance considerations, provides considerations for future improvements and modifications, and conducts a comparative analysis with other existing implementations.

In the concluding chapter, key findings are encapsulated and a conclusion is drawn. The end of this thesis provides an outlook into the future of QUIC.